import "vga.bq";

pub type Screen = struct {
    buffer Screen::Buffer,
};

pub type Screen::Character = struct {
    ascii_character u8,
    backfront_color u8,
};

pub type Screen::Buffer = struct {
    characters [*]Screen::Character,
    current_column usize,
    current_row usize,
};

pub fn Screen::clear(screen *Screen, background vga::Color, foreground vga::Color) {
    screen.buffer.current_row = 0;
    screen.buffer.current_column = 0;

    var row usize = 0;

    while row < vga::buffer::height {
        var column usize = 0;

        while column < vga::buffer::width {
            var index = row * vga::buffer::width + column;

            screen.buffer.characters[index].ascii_character = ' ';
            screen.buffer.characters[index].backfront_color = (background as u8 << 4) | foreground;

            column += 1;
        }

        row += 1;
    }
}

pub fn Screen::write(screen *Screen, ascii_character u8, background vga::Color, foreground vga::Color) {
    switch (ascii_character) {
        '\n' => {
            if (screen.buffer.current_row += 1) == vga::buffer::height {
                screen.buffer.current_row = 0;
            }

            screen.buffer.current_column = 0;
        },

        else => {
            var index = screen.buffer.current_row * vga::buffer::width + screen.buffer.current_column;

            screen.buffer.characters[index].ascii_character = ascii_character;
            screen.buffer.characters[index].backfront_color = (background as u8 << 4) | foreground;

            if (screen.buffer.current_column += 1) == vga::buffer::width {
                screen.buffer.current_column = 0;

                if (screen.buffer.current_row += 1) == vga::buffer::height {
                    screen.buffer.current_row = 0;
                }
            }
        }
    }
}

pub fn Screen::print(screen *Screen, string [*]const u8) {
    while string.* != 0 {
        Screen::write(screen, string.*, vga::Color::black, vga::Color::white);

        string += 1;
    }
}
